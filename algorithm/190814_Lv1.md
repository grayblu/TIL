# 190814 알고리즘

문제 출처: 프로그래머스 [모의고사]

https://programmers.co.kr/learn/courses/30/lessons/42840

설명 요약: 3명의 수포자 중 모의고사에서 가장 많은 문제를 맞힌 사람이 누구인지 맞추기



작성한 코드

```python
def solution(answer):

    no1 = [1,2,3,4,5,]
    no2 = [2,1,2,3,2,4,2,5,]
    no3 = [3,3,1,1,2,2,4,4,5,5,]
	people = {1:no1, 2:no2, 3:no3}
	
    result = []

    for key in range(1,len(people)+1):
        person = people.get(key)
        
        p =[]
        for a in range(len(answer)):
            p.append(person[a%(len(person))])
        
        count = 0
        for person_answer, test_answer in zip(p, answer):
            if person_answer == test_answer:
                count += 1
        print(f'수포자{key}는 {count} 문제를 맞혔습니다.')
        people[key] = count
        result.append(count)
        
	a = max(result)
	return [k for k,v in people.items() if v == a]

```



해당 문제 설명을 읽고 요구사항은 빠르게 이해가 되었으나 방법이 쉽게 떠오르지 않았다. 루프를 통해 수포자의 답안과 정답을 하나씩 비교하는 것 이 외에는 어디서 부터 알고리즘을 시작할 지 생각하는데 시간이 걸렸다. 한 번에 해결하려고 달려들기 보다는 차근차근 탑을 쌓듯이 문제를 해결해야 된다는 생각으로 절차를 만들어 갔다(남들에게는 쉽게 느껴질 지 모르지만 초보에게는 어려운 문제였다).

우선 입출력 예시 결과에 근접하기 위한 절차를 생각했다.

> 수포자들이 찍는 방식을 리스트로 저장한다
>
> 정답은 1 ~ 5 중 하나이며, 해당 숫자를 요소로 갖는 임의의 리스트를 함수 매개변수에 전달한다
>
> 루프를 통해 수포자의 답안과 정답을 비교하며 맞춘 개수를 카운트한다



여기까지 절차를 만들고 실행해 보면서 문제를 인식했다. 문제를 인식했다는 것은 알고리즘에 필요한 단서를 발견하는 것이다.

​	`모의고사의 문제 수와 수포자의 정답과 같아야 한다.` => `그래야 루프를 통해 정답 개수를 파악할 수 있다`

​	`수포자 리스트를 문제 수 만큼 순회하면서 각 요소를 새로운 리스트에 저장한다 `

위의 문제와 해결 방안을 발견하고 나서는 알고리즘을 짜는 것에 탄력을 받았고, 각 수포자가 맞춘 개수를 확인하며 문제의 답에 근접했다.



최종적으로 알고리즘을 완성하기 위해서는 또 한 번의 고민이 필요했다.

​	`가장 정답을 많이 맞춘 수포자는 누구인가` => `딕셔너리의 값들 중 최대값은?? 그 값에 해당하는 키는 ??`

​	`최대값이 같으면 수포자를 오름차순 정렬한다`

이 문제를 놓고 `if 최대값에 해당하는 요소 == 3`를 통해 구현했고, 테스트 과정에서 실수를 발견했다.

​	`최대값이 두 개인 경우도 있다`

그래서 딕셔너리의 값을 가지고 키를 구하는 방법을 찾아 알고리즘을 완성할 수 있었다.



이 문제를 푸는 데 4시간이 걸렸다. 시간도 오래 걸렸고 코드 효율성도 떨어진다. 중요한 것은 문제를 포기하지 않고 끝까지 고민하여 해결했다는 것이다. 방법을 찾아가면서 퍼즐을 맞춰나가는 과정은 힘들지만 완성하고 나면 보람있다. 특히, 이전이었으면 어느 정도 시도하다가 접거나 정답을 봤을 것이다(물론 방법을 정말 모르면 힌트를 얻어 다시 도전하는 것도 나쁘지 않다고 생각한다).  지금처럼 꿋꿋히 훈련해 나간다면 성장할 것이라고 믿는다. 그리고 타인의 코드와 비교해 보면서 코드를 개선하고 다양한 방법을 익혀야겠다.